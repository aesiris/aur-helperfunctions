#!/bin/bash
#
# aur-helperfunction
#
#   Helps managing a local repo of AUR packages
# 
# FUNCTIONS
#  aur-check
#  aur-sobump
#  aur-get package
#  aur-info package [package2 [...]]
#  aur-search string
#  makepkg
#  repo-upd
#  repo-add package.tar.xz
#  repo-remove package

if [[ -f $HOME/.aur-helperfunctions.conf ]]; then
	. $HOME/.aur-helperfunctions.conf
else
	[[ "$REPONAME" ]] || echo 'please configure ~/.aur-helperfunctions.conf and resource before doing anything'
fi

: ${REPONAME:=aur}
: ${REPODIR:=$HOME/aur/repo}
: ${REPODB:=$REPODIR/${REPONAME}.db.tar.gz}
: ${SRCDIR:=$HOME/aur/src}
: ${PKGBUILDIR:=$HOME/aur/src}
: ${EXCLUDE:=$HOME/aur/exclude}

for dir in "${SRCDIR}" "${REPODIR}" "${PKGBUILDIR}"; do
	if [[ ! -d "$dir" ]]; then
		echo "missing directory: $dir"
		echo "fix before doing anything"
	fi
done

if ! grep -q "[$REPONAME]" /etc/pacman.conf; then
	# tell how to add local repo to /etc/pacman.conf
	cat<<-END
		# repo $REPONAME not configured in pacman.conf 
		# paste and run this from a root shell, or add to pacman.conf the lines between EOFs
		cat >> /etc/pacman.conf <<EOF

		[$REPONAME]
		SigLevel = Optional TrustAll
		Server = file://$REPODIR
		EOF
	END
fi

aur-get() {
	# download sources for package from AUR

	echo 'getting package '$1' from AUR'
	pushd "$SRCDIR" || return 1
	[[ -d "$PKGBUILDIR/$1" ]] && mv "$PKGBUILDIR/$1" "$PKGBUILDIR/$1-prev"
	[[ -e "$1.tar.gz" ]] && mv "$1.tar.gz" "$1-prev.tar.gz"
	if wget -q "https://aur.archlinux.org/packages/${1:0:2}/$1/$1.tar.gz"; then
		cd "$PKGBUILDIR" && tar xf "$SRCDIR/$1.tar.gz" && cd "$1"
	else
		false
	fi
	if (($?!=0)); then
		echo "error $1" >&2
		pushd
	fi
}

aur-local-packages() {
	# print list of installed packages from local repo
	# -a: print all packages, including those in repo but not installed
	# -e: exclude packages from EXCLUDE variable

	local pacout=$( LANG=C pacman -Sl "$REPONAME" )
	local allpkg="" exclude=""
	while (($#>0)); do
		case "$1" in
			"-a" ) allpkg=yes;;
		  	"-e" ) exclude=yes;;
		esac
		shift
	done

	if [[ "$exclude" ]] && [[ "$EXCLUDE" ]]; then
		if [[ -e "$EXCLUDE" ]] && [[ "${EXCLUDE:0:1}" == "/" ]] ; then
			pacout=$( grep -v -F -f "$EXCLUDE" <<<"$pacout" )
		else
			local excludes=$( sed -e 's/,/\n/g' <<<"$EXCLUDE" )
			pacout=$( grep -v -F -e "$excludes" <<<"$pacout" )	
		fi
	fi
	if [[ "$allpkg" ]]; then
		awk -F " " '{ print $2,$3;}' <<<"$pacout"
	else
		awk -F " " '/installed/ { print $2,$3;}' <<<"$pacout"
	fi
}

aur-search () {
	# search packages matching string on AUR

	local json="$( wget "https://aur.archlinux.org/rpc.php?type=search&arg=$1" -o /dev/null -O - )"

	if [[ ! "$json" ]] || grep -q error <( jshon <<<"$json" -e type ); then
		echo "Failed to search $1"
		return 1
	fi
	local resultsn=$( jshon <<<"$json" -e results -l )
	echo "$resultsn matching packages in AUR"
	if [[ ! "$resultsn" ]] || [[ "$resultsn" == 0 ]]; then return 1; fi

	exec 3< <( jshon <<<"$json" -e results -a -e Name -u )
	exec 4< <( jshon <<<"$json" -e results -a -e Description -u )
	exec 5< <( jshon <<<"$json" -e results -a -e Version -u )
	local name description version
	while read name <&3 && read description <&4 && read version <&5; do
		echo -e "$name $version\n    $description"
	done
	exec 3<&- 4<&-
}

aur-info() {
	# get package info from AUR
	# aur-info [-a] package1 [package2 [...]]
	# -a: fill version array

	if [[ "$1" == "-a" ]]; then
		shift
		local getver=yes
	fi

	local args=""
	local pkg
	for pkg in "$@"; do
		args+='&arg[]='"$pkg"
	done
	local json="$( wget "https://aur.archlinux.org/rpc.php?type=multiinfo${args}" -o /dev/null -O - )"

	if [[ ! "$json" ]] || grep error <( jshon <<<"$json" -e type ) > /dev/null; then
		echo "Failed to get any AUR info"
		return 1
	fi
	if [[ "$( jshon <<<"$json" -e results -l )" == 0 ]]; then
		echo "0 matching packages in AUR"
		return 1
	fi

	if [[ ! "$getver" ]]; then
		jshon <<<"$json" -e results
	else
		exec 3< <( jshon <<<"$json" -e results -a -e Name -u )
		exec 4< <( jshon <<<"$json" -e results -a -e Version -u )
		exec 5< <( jshon <<<"$json" -e results -a -e Maintainer )

		while read name <&3 && read version <&4 && read maint <&5; do
			aurversion["$name"]="$version"
			aurmaint["$name"]="$maint"
		done
		exec 3<&- 4<&- 5<&-
	fi
}

version_eq () { [[ "$1" == "$2" ]]; }
version_ge () {
        sort=$(echo -e "$1\n$2" | sort -V)
        lower=$(head -n 1 <<<"$sort")
	[[ "$2" == "$lower" ]]
}
version_gt () { ! version_eq "$1" "$2" && version_ge "$1" "$2"; }
version_ne () { ! version_eq "$1" "$2"; }
version_lt () { ! version_ge "$1" "$2"; }
version_le () { ! version_gt "$1" "$2"; }

aur-check () {
	# check for updates on AUR
	# -a to check every package in repo (including not installed)
	# -v verbose output: output packages already up to date

	local allpkg="" showall=""
	while (($#>0)); do
		case "$1" in
		  	"-v" ) showall=yes;;
			"-a" ) allpkg="-a";;
		esac
		shift
	done

	local listupdated=() listtoupdate=() listnotfound=() listnotmaintained=()
	
	local -A localversion=() 
	local -a packages=()
	local package version
	while read package version; do
		packages+=("$package")
		localversion["$package"]="$version"
	done < <( aur-local-packages -e "$allpkg" )
	
	local -A aurversion=()
	local -A aurmaint=()
	aur-info -a "${packages[@]}"
	(($?==1)) && return 1

	local aur loc
	for package in "${packages[@]}"; do
		loc="${localversion["$package"]}"
		aur="${aurversion["$package"]}"
		if [[ "$aur" ]]; then
			if version_eq "$loc" "$aur"; then
				listupdated=( "${listupdated[@]}" "$package" )
			elif version_gt "$loc" "$aur"; then
				listupdated=( "${listupdated[@]}" "$package ($loc > $aur)" )
			else
				listtoupdate=( "${listtoupdate[@]}" "$package ($loc < $aur)" )
			fi
			if [[ "${aurmaint["$package"]}" == null ]]; then
				listnotmaintained=( "${listnotmaintained[@]}" "$package" )
			fi
		else
			listnotfound=( "${listnotfound[@]}" "$package" )
		fi
	done
	
	local return=1
	local OLDIFS="$IFS"
		IFS=$'\n'
		local COLG="\033[1;32m" COLR="\033[1;31m" COLN="\033[0m" COLE="\033[1;39m"
		[[ "$showall" ]] && ((${#listupdated[@]}>0)) &&\
			echo -e "${COLG}Updated${COLN}\n${listupdated[*]}${COLN}"
		((${#listnotmaintained[@]}>0)) &&\
			echo -e "${COLR}Unmaintained${COLN}\n${listnotmaintained[*]}${COLN}" && return=0
		((${#listnotfound[@]}>0)) &&\
			echo -e "${COLR}Not found in AUR${COLN}\n${listnotfound[*]}${COLN}" && return=0
		((${#listtoupdate[@]}>0)) &&\
			echo -e "${COLR}To update${COLE}\n${listtoupdate[*]}${COLN}" ||\
			echo -e "${COLG}None to update${COLN}"
	IFS="$OLDIFS"
	(($return&${#listtoupdate[@]}==0))
}

aur-sobump () {
	# check for missing dynamic libraries

	local LINKER=/lib/ld-2.16.so 
	local pkg i missing outraw outpac
	
	for pkg in $( aur-local-packages | cut -f 1 -d " " ); do
		for i in $( pacman -Qql $pkg ); do
			if $LINKER --verify "$i"; then	
				missing=$( $LINKER --list "$i" 2>&1 | grep "error while loading shared libraries" | cut -f 1,3 -d ':')
				if (( ${#missing} != 0 )); then
					outraw+="$missing\n"
					outpac+="$pkg\n"
				fi
			fi
		done
	done

	if ((${#outraw}>0)); then
		missinglibs=$( cut -f 1 -d ':' <<<"$outraw" )
		echo "Possible Rebuild:"
		echo '(type echo "$missinglibs" for missing files")'
		sort -u <<<"$outpac"
	else
		echo "No missing libraries"
	fi

}

repo-upd() {
	# updates local repo adding most recently built packages
	repo-add $(find "$REPODIR" -mtime -1 -type f -iname '*.tar.xz' )
}

repo-add() {
	# repo-add package.tar.xz
	# add package to local repo
	command repo-add "$REPODB" "$@"
}

repo-remove() {
	# repo-remove package
	# remove package from local repo
	command repo-remove "$REPODB" "$@"
}

makepkg() {
	# wraps makepkg copying most recently built package to local repo

	export PKGDEST="${REPODIR}"
	if command makepkg "$@"; then
		files=(*.tar.xz)
		#uncomment for only newest version
		#file="$( ( IFS=$'\n'; sort -V <<<"${files[*]}"; ) | tail -n 1 )"
		[[ -e "$file" ]] && repo-add "${file}"
	fi
}
